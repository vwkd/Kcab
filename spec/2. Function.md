# Function



## Introduction

- reusable piece of code with its own scope
- inherits scope of parent where is declared (not where is called), uses closure
- expression, can be assigned to variable, given as argument to other functions, first-class, etc.
- no macros, just functions
 


## Declaration

```
name ->: {
  "Hello {name}!" <-
} =: hello
```

- operator `->:`, like variable assignment but with arrow
- is an expression, can be assigned to variable
- has its own scope closing over outer scope
- return value is last value like in Rust, defaults to `None`
- optionally can use `<-` to return earlier, e.g. in a branch

```js
const hello = name => { 
  return `Hello ${name}!`
}
```

- arguments are not backwards, because needs to see first, like initial variable in loop
- multiple arguments separated by commas
<!-- todo: ?? maybe group operator for multiple arguments would look better `(x, y) -> add`, or `[x, y] -> add` like a box of items that is shipped to function -->
- without arguments needs to still include `->:` to differentiate it from block

```
->: {

}
```



## Calling

```
"Peter" -> hello
```

- operator `->`, like pointing the reader to the place where needs to continue reading

```js
hello("Peter")
```



## Immediately Invoked Function Expression (IIFE)

```
"Peter" -> name ->: {
  "Hello {name}!"
}
```

- anonymous function that's called at declaration

```js
((name) => {
  return `Hello ${name}!`
})("Peter")
```

- if has no arguments

```
-> ->: {
  "Hello World!"
}
```

- can use shorthand to leave of `->` and `->:`
- also called "block"

```
{
  "Hello World!"
}
```

```js
(() => {
  
})()
```