# Type Annotation



## Introduction

- annotation of data types
- like a meta language, defines what code should do
- all code is strongly typed, like in Rust
- no introspection, like in Rust
- should visually interfere as little as possible with actual code
- IDE is encouraged to hide types by default and show them inline when needed, e.g. on hover/tap, autocomplete, etc.



## Notation

- notation `#`, like a tag, clearly visible to not confuse
- `#` for in-line type
- `#* *#` for multi-line type
<!-- todo: good idea? only useful in variable declarations... -->
- beware: unlike in-line comment ❗️
- use `()` to group function and object types



## Types

### Scalar types

```
Number
```

- single-line
- like object name, i.e. uppercase

### Function

```
<type>, ..., <type> ->: <type>
```

- single-line
- beware: no parameter names since fully determined by order ❗️

### Object

```
[key1 # <type>, ..., keyN # <type>]
```

```
[
  key1 # <type>
  ...
  keyN # <type>
]
```

- single-line or multi-line
- beware: for single line uses commas although actual object doesn't ❗️



## Declarations

- optional when can be inferred
- types of imported modules are imported automatically, e.g. data types

### Variable

```
42 =: myvar # Number

12 =: myvar2
# Number
```

```ts
const myvar: number = 42;

/**
 * @type {number}
 */
const myvar2 = 12;
```

- after name, can be in new line
- can check that function is of a function type
<!-- todo: figure out String interpolation -->

```
name ->: {
  "Hello {name}"
} =: myfunc
# String ->: String
```

```ts
const myfunc: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- can check that object is of an object type
- no "implements" for "at least but maybe more", since is strictly typed

```
[
  "Peter" =: name
  25 =: age
] =: myobj
# [name # String, age # String]
```

```ts
const myobj: {name: string, age: string} = {
  name: "Peter",
  age: 25,
}
```

### Function

```
name # String ->: {
  "Hello {name}"
} # String
```

```ts
(name: string): string => {
  return `Hello ${name}`!
}
```

- beware: don't confuse return type with variable type, on same line as closing bracket ❗️

### Object

```
[
  "Peter" =: name # String
  25 =: age # Number
]
```

```ts
// note, TS doesn't allow to type a property (not method)
// needs to type variable
{
  name: "Peter",
  age: 25,
}
```



## Type alias

```
# <type> =: MyType
```

```ts
type MyType = <type>

// additionally, for object types
interface MyType = <object_type>
```

- alias for a type
- name must be UpperCamelCase



## Type union

<!-- todo: type union
Rust uses enums instead, e.g. Result, Option, etc.
-->

- union of two types

```ts
type MyType = <type> | <type>

// additionally, for object types
interface MyType extends <object_type> = <object_type>
```



## Type intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea/ -->



## Object composition

- like spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
# [
  ... # <object_type>
  key1 # <type>
  keyN # <type>
]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
# [
  key1 # <type>
  keyN # <type>
  ... # <object_type>
]
```



## Generics

- type variable
<!-- todo: how to write it?
Just use name? But then can't differentiate from spelling mistake for existing type
-->
- actually only ever used on functions, since only place where accepts input
<!-- todo: not on objects? not on type variables? -->