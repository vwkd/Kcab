# Type Annotation



## Introduction

- annotation of data types
- like a meta language, defines what code should do
- all code is strongly typed, like in Rust
- no introspection, like in Rust
- IDE is encouraged to hide types by default and show them inline when needed, e.g. on hover/tap, autocomplete, etc.



## Notation

```
# type
```

- notation `#`, like a tag, clearly visible to not confuse
- at end to visually interfere as little as possible with actual code
- use `()` to group function and object types

<!-- todo: allow multi-line in declaration? What -->



## Types

- scalar types: like object name
- function: `param1 # <type>, ..., paramN # <type> ->: <type>`
- object: `[key1 # <type>, ..., keyN # <type>]`



## Declarations

- optional when can be inferred
- types of imported modules are imported automatically, e.g. data types

### Variable

```
123 =: myvar # Number
```

```ts
const myvar: number = 54;
```

- after name
- can check that function is of a function type
<!-- todo: figure out String interpolation -->

```
name ->: {
  "Hello {name}"
} =: myfunc # name # String ->: String
```

```ts
const myfunc: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- can check that object is of an object type
- no "implements" for "at least but maybe more", since is strictly typed

```
[
  "Peter" =: name
  25 =: age
] =: myobj # [name # String, age # String]
```

```ts
const myobj: {name: string, age: string} = {
  name: "Peter",
  age: 25,
}
```

### Function

```
name # String ->: {
  "Hello {name}"
} # String
```

```ts
(name: string): string => {
  return `Hello ${name}`!
}
```

### Object

```
[
  "Peter" =: name # String
  25 =: age # Number
]
```

```ts
// note, TS doesn't allow to type a property (not method)
// needs to type variable
{
  name: "Peter",
  age: 25,
}
```



## Type alias

```
# <type> =: name
```

```ts
type name = <type>

// additionally, for object types
interface name = <object_type>
```

- alias for a type
- names must be UpperCamelCase



## Type union

<!-- todo: type union
Rust uses enums instead, e.g. Result, Option, etc.
-->

- union of two types

```ts
type name = <type> | <type>

// additionally, for object types
interface name extends <object_type> = <object_type>
```



## Type intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea/ -->



## Object composition

- like spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
# [
  ... # <object_type>
  key1 # <type>
  keyN # <type>
]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
# [
  key1 # <type>
  keyN # <type>
  ... # <object_type>
]
```