# Type Annotation



## Introduction

- annotation of data types for variables and functions
- like a meta language, allows to analyze code for correctness
- strongly typed, like in Rust
- no introspection, like in Rust



## Types

### Scalar types

```
<type>
```

- single-line
- like object name, i.e. uppercase

### Function

```
(<type>, ..., <type>) to <type>
```

- single-line
- beware: no parameter names since fully determined by order ❗️

### Object

```
[key1 # <type>, ..., keyN # <type>]
```

```
[
  key1 # <type>
  ...
  keyN # <type>
]
```

- single-line or multi-line
- beware: for single line uses commas although actual object doesn't ❗️

### Literal Types

```
value
```

- single-scalar-value type
- single-line



## Declarations

- like a tag, clearly distinguishable to not confuse with code
- after code, second priority to not interfere with code
- IDE is encouraged to hide types by default and show them inline when needed, e.g. on hover/tap, autocomplete, etc.
- `#` for in-line type
- `#* *#` for multi-line type
<!-- todo: good idea? only useful in variable declarations... -->
- beware: unlike in-line comment ❗️
- use `()` to group function and object types
- optional when can be inferred
- mutable variable infers general type, immutable variable infers literal type
- types of imported modules are imported automatically, e.g. data types

### Variable

- after name

```
42 is myvar alias # Number
```

```
42 is myvar alias
# Number
```

- can be in new line
<!-- todo: good idea? the more options the more complexity -->

```ts
const myvar: number = 42;
```

```ts
/**
 * @type {number}
 */
const myvar = 42;
```

- can check that function is of a function type

```
&{
  in is name alias
  "Hello {name}"
} is myfunc alias
# String to String
```

```ts
const myfunc: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- can check that object is of an object type
- no "implements" for "at least but maybe more", since is strictly typed

```
[
  "Jupiter" is name alias
  25 is age alias
] is myobj alias
# [name # String, age # String]
```

```ts
const myobj: {name: string, age: string} = {
  name: "Jupiter",
  age: 25,
}
```

- same in object as is just scope

```
[
  "Jupiter" is name alias # String
  25 is age alias # Number
]
```

```ts
// note, TS doesn't allow to type a property (not method)
// needs to type variable
{
  name: "Jupiter",
  age: 25,
}
```

### Function

```
&{
  in is name alias # String
  "Hello {name}"
} # String
```

```ts
(name: string): string => {
  return `Hello ${name}`!
}
```

```
&{
  in is (name, age) alias # (String, Number)

} is hello alias # String
```

- beware: don't confuse return type with variable type, on same line as closing bracket ❗️



## Type alias

- like variable in code, just in type

```
# <type> is MyType alias
```

```ts
type MyType = <type>

// additionally, for object types
interface MyType = <object_type>
```

- alias for a type
- name must be UpperCamelCase



## Type union

```
# (<type>, ..., <type>)
```

```
#*
(
  <type>
  ...
  <type>
) is MyType alias
*#
```

```ts
type MyType = <type> | <type>

// additionally, for object types
interface MyType extends <object_type> = <object_type>
```

- union of two types
- visually similar to object type, but with parentheses and no field names
- single-line or multi-line
- can create enum using type union of literal types
<!-- todo: how to use fields on enum, like in Rust? can't use complex type since has no would loose "name" -->



## Type intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea/ -->



## Object composition

- like spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
# [
  ... # <object_type>
  key1 # <type>
  keyN # <type>
]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
# [
  key1 # <type>
  keyN # <type>
  ... # <object_type>
]
```



## Generics

- like type alias, but mutable

```
# <type> is MyType alias mutable
```

- can code

```
# if <type2> ?= String { <type2> is MyType }
```

- actually only ever used on functions, since only place where accepts input
<!-- todo: not on objects? not on type variables? -->
