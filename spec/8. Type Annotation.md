# Type Annotation



## Introduction

- annotation of data types for variables and functions
- like a meta language, allows to analyze code for correctness
- strongly typed, like in Rust
- no introspection, like in Rust
- no separate code, part of code itself, e.g. imported as part of modules
- IDE is encouraged to hide types by default, show them inline when needed (hover, autocomplete), e.g. list of function input and output, list of object keys, etc.



## Types

### Scalar types

```
<type>
```

- single-line
- like object name, i.e. uppercase

### Function

```
<type> to <type>
```

- single-line
- no grouping necessary since single input and output value

### Object

```
[key1 is <type>
 keyN is <type>]
```

- multi-line, like code
- composition using spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
[
  ... is <object_type>
  key1 is <type>
  keyN is <type>
]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
[
  key1 is <type>
  keyN is <type>
  ... is <object_type>
]
```

### Literal Types

```
value
```

- single-scalar-value type
- single-line



## Declarations

- like a tag, clearly distinguishable to not confuse with code
- optional when can be inferred
- `#` for in-line type
<!-- todo: how to do multi-line types, needs start and end delimiter -->
- beware: unlike in-line comment ❗️
- use `()` to group function and object types

### Variable

- after code, second priority to not interfere with code
- type mandatory if uninitialized
- scalar type

```
42 is myvar # Number
// optional since inferred
```

```ts
const myvar: number = 42;
```

- can be in new line
<!-- todo: good idea? the more options the more complexity -->

```
42 is myvar
# Number
// optional since inferred
```

```ts
/**
 * @type {number}
 */
const myvar = 42;
```

- mutable variable infers general type, immutable variable infers literal type
- function type

```
&{
  in is name
  "Hello {name}"
} is hello
# String to String
// should type function instead, then optional since inferred
```

```ts
const hello: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- object type
- no `implements` for "at least but maybe more", since is strictly typed

```
[
  "Jupiter" is name
  25 is age
] is person
# [ name is String
#   age is String ]
// should type object instead, then optional since inferred
```

```ts
const person: {name: string, age: string} = {
  name: "Jupiter",
  age: 25,
}
```

### Function

- inside function body, function is self-contained
- special `in` and `out` keywords, similar to object type
- convention to put at beginning, but not necessary
- `out` not inferred from returned values because wants to check for mistakes
- using `in` infers

```
&{
  # in is String
  # out is String
  in is name
  "Hello {name}"
}
```

```ts
(name: string): string => {
  return `Hello ${name}`
}
```

```
&{
  # in is [ name is String
  #         age is Number ]
  # out is String
  name of in is name
  age of in is age
  "{name} is {age}"
}
```

```ts
(name: string, age: number): string => {
  return `${name} is ${age}`
}
```

### Object

- like variable as object is just scope

```
[
  "Jupiter" is name # String
  25 is age # Number
]
```

```ts
// beware: TS doesn't allow to type a property (not method)
// can only type variable instead
{
  name: "Jupiter",
  age: 25,
}
```



## Type alias

- alias for a type, like immutable variable in code
- name by convention UpperCamelCase

```
# <type> is MyType
```

```ts
type MyType = <type>

// additionally, for object types
interface MyType = <object_type>
```



## Type union

- union of two types
- can create enum using type union of literal types
<!-- todo: how to use fields on enum, like in Rust? can't use complex type since has no would loose "name" -->

```
# <type> | <type>
```

```ts
<type> | <type>

// additionally, for object types
interface MyType extends MyObjectType = <object_type>
```



## Type intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea? -->



## Generics

- like type alias, but mutable
<!-- todo: more like variables whose value isn't clear without evaluation ?! -->
- actually only ever used on functions, since only place where accepts input
<!-- todo: not on objects? not on type variables? -->

```
# <type> is MyType mutable
```

- can code

```
# if <type2> ?= String { <type2> is MyType }
```