# Type Annotation



## Introduction

- annotation of data types
- like a meta language, defines what code should do
- all code is strongly typed, like in Rust
- no introspection, like in Rust
- should visually interfere as little as possible with actual code
- IDE is encouraged to hide types by default and show them inline when needed, e.g. on hover/tap, autocomplete, etc.



## Notation

- like a tag, clearly visible to not confuse
- `#` for in-line type
- `#* *#` for multi-line type
<!-- todo: good idea? only useful in variable declarations... -->
- beware: unlike in-line comment ❗️
- use `()` to group function and object types



## Types

### Scalar types

```
# <type>
```

- single-line
- like object name, i.e. uppercase

### Function

```
# (<type>, ..., <type>) of <type>
```

- single-line
- beware: no parameter names since fully determined by order ❗️

### Object

```
# [key1 # <type>, ..., keyN # <type>]
```

```
#*
[
  key1 # <type>
  ...
  keyN # <type>
]
*#
```

- single-line or multi-line
- beware: for single line uses commas although actual object doesn't ❗️

### Literal Types

```
# value
```

- single-scalar-value type
- single-line



## Declarations

- types come after code, second priority
- optional when can be inferred
- mutable variable infers general type, immutable variable infers literal type
- types of imported modules are imported automatically, e.g. data types

### Variable

- after name

```
42 as myvar # Number
```

```
42 as myvar
# Number
```

- can be in new line
<!-- todo: good idea? the more options the more complexity -->

```ts
const myvar: number = 42;
```

```ts
/**
 * @type {number}
 */
const myvar = 42;
```

- can check that function is of a function type

```
name of {
  "Hello {name}"
} as myfunc
# String of String
```

```ts
const myfunc: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- can check that object is of an object type
- no "implements" for "at least but maybe more", since is strictly typed

```
[
  "Jupiter" as name
  25 as age
] as myobj
# [name # String, age # String]
```

```ts
const myobj: {name: string, age: string} = {
  name: "Jupiter",
  age: 25,
}
```

### Function

```
name # String of {
  "Hello {name}"
} # String
```

```ts
(name: string): string => {
  return `Hello ${name}`!
}
```

- beware: don't confuse return type with variable type, on same line as closing bracket ❗️

### Object

```
[
  "Jupiter" as name # String
  25 as age # Number
]
```

```ts
// note, TS doesn't allow to type a property (not method)
// needs to type variable
{
  name: "Jupiter",
  age: 25,
}
```



## Type alias

```
# <type> as MyType
```

```ts
type MyType = <type>

// additionally, for object types
interface MyType = <object_type>
```

- alias for a type
- name must be UpperCamelCase



## Type union

```
# (<type>, ..., <type>)
```

```
#*
(
  <type>
  ...
  <type>
) as MyType
*#
```

```ts
type MyType = <type> | <type>

// additionally, for object types
interface MyType extends <object_type> = <object_type>
```

- union of two types
- visually similar to object type, but with parentheses and no field names
- single-line or multi-line
- can create enum using type union of literal types
<!-- todo: how to use fields on enum, like in Rust? can't use complex type since has no would loose "name" -->



## Type intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea/ -->



## Object composition

- like spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
# [
  ... # <object_type>
  key1 # <type>
  keyN # <type>
]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
# [
  key1 # <type>
  keyN # <type>
  ... # <object_type>
]
```



## Generics

- type variable
<!-- todo: how to write it?
Just use name? But then can't differentiate from spelling mistake for existing type
-->
- actually only ever used on functions, since only place where accepts input
<!-- todo: not on objects? not on type variables? -->
