# Type Annotation



## Introduction

- annotation of data types for variables and functions
- types are own programming language
- runs type code before running actual code
- allows to find some errors in actual code
- reduces values in program to a few distinct values (types), reduces complexity of program to be able to reason about it on higher level



## Design

- strongly typed, like in Rust
- no introspection, like in Rust
- no separate code, part of code itself, e.g. imported as part of modules
- IDE is encouraged to hide types by default, show them inline when needed (hover, autocomplete), e.g. list of function input and output, list of object keys, etc.



## Types

### Scalar

```
<type>
```

- single-line
- built-in, names by convention UpperCamelCase

### Function

```
<type> to <type>
```

- single-line
- no grouping necessary since single input and output value

### Object

```
[ key1 is <type>, keyN is <type> ]
```

- single-line, like shorthand in code
- composition using spread operator
- spread at beginning uses all declarations from object type, can't override using own declarations because repeated declaration throws

```
[ ... is <object_type>, key1 is <type>, keyN is <type> ]
```

- spread at end only uses declarations from object type for which doesn't already have own declaration

```
[ key1 is <type>, keyN is <type>, ... is <object_type> ]
```

### Literal

```
value
```

- single-scalar-value type
- single-line



## Declarations

- like a tag, clearly distinguishable to not confuse with code
- optional when can be inferred
- `#` for in-line type
- beware: unlike in-line comment ❗️
- beware: can't use any multi-line syntax ❗️

### Variable

- after code, second priority to not interfere with code
- type mandatory if uninitialized
- scalar type

```
42 is myvar # Number
// optional since inferred
```

```ts
const myvar: number = 42;
```

- can be in new line
<!-- todo: good idea? the more options the more complexity -->

```
42 is myvar
# Number
// optional since inferred
```

```ts
/**
 * @type {number}
 */
const myvar = 42;
```

- mutable variable infers general type, immutable variable infers literal type
- function type

```
&{
  in is name
  "Hello {name}"
} is hello
# String to String
// should type function instead, then optional since inferred
```

```ts
const hello: (name: string) => string = function(name) {
  return `Hello ${name}`!
}
```

- object type
- no `implements` for "at least but maybe more", since is strictly typed

```
[
  "Jupiter" is name
  25 is age
] is person
# [ name is String
#   age is String ]
// should type object instead, then optional since inferred
```

```ts
const person: {name: string, age: string} = {
  name: "Jupiter",
  age: 25,
}
```

### Function

- inside function body, function is self-contained
- special `in` and `out` keywords, similar to object type
- convention to put at beginning, but not necessary
- `out` not inferred from returned values because wants to check for mistakes
- using `in` infers

```
&{
  # in is String
  # String out
  in is name
  "Hello {name}"
}
```

```ts
(name: string): string => {
  return `Hello ${name}`
}
```

```
&{
  # in is [ name is String, age is Number ]
  # String out
  name of in is name
  age of in is age
  "{name} is {age}"
}
```

```ts
(name: string, age: number): string => {
  return `${name} is ${age}`
}
```

- generic

```
&{
  # in is MyInput
  # MyInput out
  in
} is identity
```

```ts
const identity = <MyInput>(input: MyInput): MyInput => {
  return input
}
```

- at call argument is inferred from input, no way to set argument manually, unlike in TypeScript

```
"Jupiter" to identity
```

```
identity<string>("Jupiter")
```

### Object

- like variable as object is just scope

```
[
  "Jupiter" is name # String
  25 is age # Number
]
```

```ts
// beware: TS doesn't allow to type a property (not method)
// can only type variable instead
{
  name: "Jupiter",
  age: 25,
}
```



## Types

### Variable

- type variable
- immutable, initialized at declaration
- like in code
- name by convention UpperCamelCase

```
<type> is MyType
```

```ts
type MyType = <type>

// additionally, for object types
interface MyType = <object_type>
```

- beware: also called "type alias" ❗️

### Union

- union of two types
- can create enum using type union of literal types
<!-- todo: how to use fields on enum, like in Rust? can't use complex type since has no would loose "name" -->

```
<type> | <type>
```

```ts
<type> | <type>

// additionally, for object types
interface MyType extends MyObjectType = <object_type>
```

### Intersection

- intersection of two types
- no, since function overloading exists
<!-- todo: good idea? -->

### Function

- type function
- returns output type depending on input type
- beware: the function is confusingly also called "generic type" ❗️
- beware: don't confuse "type function" with "function type" ❗️
- can use to make types more reusable
- necessary for functions that vary their output type based on their input type and which are called later  (not IIFE), because input type not known at time of declaration

#### Declaration

- like function in code
- single input `in`, for multiple arguments use type object
- beware: don't confuse "type object" with "object type" ❗️
- assign type parameter to type variable like in code

```
&{
  in is MyInput
  [ prop is MyInput ] out
} is MyObject
```

```ts
interface MyObject<MyInput> {
  prop: MyInput
}
```

- parameter is like unknown variable, can think of as union of all possible types
- beware: the parameter is sometimes confusingly called "generic type variable" ❗️
- can use more complex logic like `if`

```
&{
  in is MyInput
  if MyInput ?= String { Number } else { String } out
} is MyType
```

```ts
type MyType<MyInput> = MyInput extends String ? Number : String
```

#### Calling

- like function in code
- multiple arguments using object type

```
Number to MyObject
```

```ts
MyObject<Number>
```