# Function



## Introduction

- reusable piece of code with its own scope
- inherits scope of parent where is declared (not where is called), uses closure
- expression, can be assigned to variable, given as argument to other functions, first-class, etc.
- no macros, just functions
- tail call optimisation
- beware: A function is not a data type! It's a control flow construct, just like a conditional, a loop (same here, actually), a block (same here, actually), etc.
- beware: A function and object are completely separate things! Not like in JavaScript. There is no object that can be called, and no function that can have properties. Can think of functions as blocks with additional features (arguments, return value, etc.), while objects are kinds of values (all values here, actually).
- beware: a function and object can't be the same. Otherwise modifying the properties and then calling it would result in different behavior since the variables in the scope changed



## Declaration

```
name of {
  "Hello {name}!"
} is hello alias
```

```js
const hello = name => { 
  return `Hello ${name}!`
}
```

- grouping operator optional if single argument
- grouping operator mandatory if multiple arguments

```
(name, age) of {

} is hello alias
```

```js
const hello = (name, age) => { 

}
```

- no declaration, just expression
- operator `of`, like variable assignment but with arrow
- is an expression, can be assigned to variable
- has its own scope closing over outer scope
- return value is last value like in Rust, defaults to `None`
- optionally can use `back` to return earlier, e.g. in a branch

```
name of {
  if (name) {
    "Hello {name}!" back
  }
  "Hello stranger!"
} is hello alias
```

```js
const hello = name => {
  if (name) {
    return `Hello ${name}!`
  }
  return "Hello stranger!" 
}
```

- multiple arguments separated by commas and surrounded by grouping operator
- without arguments needs to still include `of` to differentiate it from block

```
of {

}
```

- no optional parameters, needs to pass all arguments
<!-- todo: variadic arguments, rest parameters? for arbitrarily many parameters, e.g. add, join, etc.
what would parameter become? List, object?
can use multiple, matches greedily (longest possible match), like in TypeScript variadic tuple types?
-->
- allows overload of same name with another function with arguments of different types
<!-- todo: good idea? -->
- beware: types of at least one argument must be disjoint (can't be superset of other), otherwise compiler would have multiple choices...
<!-- todo: enough to guarantee that choices for compiler are unambiguous? -->
- block can start/end in same or separate line

```
of {

}

of
{

}

of { }
```



## Calling

```
"Jupiter" to hello
```

```js
hello("Jupiter")
```

- operator `to`, like pointing the reader to the place where needs to continue reading
- pass-by-value, like Rust
- grouping operator optional if single argument
- chained calls aren't nested if single argument without grouping operator

```
"Jupiter" to uppercase to hello
```

```js
hello(uppercase("Jupiter"))
```

- grouping operator mandatory if multiple arguments

```
("Jupiter", 42) to hello
```

```js
hello("Jupiter", 42)
```



## Immediately Invoked Function Expression (IIFE)

- anonymous function that's called at declaration

```
"Jupiter" to name of {
  "Hello {name}!"
}
```

```js
((name) => {
  return `Hello ${name}!`
})("Jupiter")
```

- if has no arguments

```
to of {
  "Hello World!"
}
```

```js
(() => {
  
})()
```

- can use shorthand to leave of `to of`
- also called "block"

```
{
  "Hello World!"
}
```



## Loop

- none, use tail recursive function instead
- an expression
- gives all benefits of functions
- can do any loop that wants, e.g. loop on multiple arguments simultaneously, condition check at beginning, etc.
- no separate syntax

```
i of loop {
  if i ?< 10 {
    i to print
    i + 1 to loop
  }
}

1 to loop
// 1, 2, ..., 9
```

```js
function loop(i) {
  if (i < 10) {
    console.log(i)
    loop(i + 1)
  }
}

loop(1);
// 1, 2, ..., 9

for (let i = 1; i < 10; i += 1) {
  console.log(i)
}
// 1, 2, ..., 9

let i = 1
while (i < 10) {
  console.log(i)
  i += 1
}
// 1, 2, ..., 9
```

- can do condition check at end

```js
function loop(i) {
  console.log(i)
  if (i < 10) {
    loop(i + 1)
  }
}

loop(1);
// 1, 2, ..., 10

// no such for loop or while loop that checks condition at end before increment
// can use do...while but increment comes before condition check
// therefore do check at beginning for previous iteration and start with one less
let i = 0;
do {
  i += 1
  console.log(i);
} while (i < 10)
// 1, 2, ..., 10
```

- can't use IIFE because anonymous expression has no identifier to refer to itself,  must declare function and call it separately
<!-- todo: how to do `continue` and `break`? -->

```
to {
  x of {
    to loop
  } is loop alias
}
```
