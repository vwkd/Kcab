# Function



## Introduction

- reusable piece of code with its own scope
- inherits scope of parent where is declared (not where is called), uses closure
- expression, can be assigned to variable, given as argument to other functions, first-class, etc.
- no macros, just functions
- tail call optimisation
- beware: A function is not a data type! It's a control flow construct, just like a conditional, a loop (same here, actually), a block (same here, actually), etc.
- beware: A function and object are completely separate things! Not like in JavaScript. There is no object that can be called, and no function that can have properties. Can think of functions as blocks with additional features (arguments, return value, etc.), while objects are kinds of values (all values here, actually).
- beware: a function and object can't be the same. Otherwise modifying the properties and then calling it would result in different behavior since the variables in the scope changed



## Declaration

<!-- todo: improve syntax to differentiate it from block -->

```
&{
  in is name alias
  "Hello {name}!"
} is hello alias
```

```js
const hello = name => { 
  return `Hello ${name}!`
}
```

- arguments just variables set when called
- immutable, can't mutate
- convention to put arguments at beginning, but not necessary
- multiple arguments in order of declaration

```
&{
  in is (name, age) alias
  "Hello {name}!"
} is hello alias
```

```js
const hello = (name, age) => { 
  return `Hello ${name}!`
}
```

- IDE is encouraged to show summary on hover over function name like argument names and types, return type
- can assign default value, used if no value is passed
<!-- todo: not intuitive? -->

```
&{
  in is "Jupiter" is name alias
  "Hello {name}!"
} is hello alias
```

```js
const hello = (name = "Jupiter") => { 
  return `Hello ${name}!`
}
```

- expression, can be assigned to variable, no declaration
- has its own scope closing over outer scope
- return value is last value like in Rust, defaults to `None`
- optionally can use `back` to return earlier, e.g. in a branch

```
&{
  in is name alias
  if (name) {
    "Hello {name}!" back
  }
  "Hello stranger!"
} is hello alias
```

```js
const hello = name => {
  if (name) {
    return `Hello ${name}!`
  }
  return "Hello stranger!" 
}
```

- no optional parameters, needs to pass all arguments
<!-- todo: variadic arguments, rest parameters? for arbitrarily many parameters, e.g. add, join, etc.
what would parameter become? List, object?
can use multiple, matches greedily (longest possible match), like in TypeScript variadic tuple types?
-->
- allows overload of same name with another function with arguments of different types
<!-- todo: good idea? -->
- beware: types of at least one argument must be disjoint (can't be superset of other), otherwise compiler would have multiple choices...
<!-- todo: enough to guarantee that choices for compiler are unambiguous? -->



## Calling

- operator `to`, like pointing the reader to the place where needs to continue reading
- pass-by-value, like Rust
- without arguments

```
to hello
```

```js
hello()
```

- grouping operator optional if single argument

```
"Jupiter" to hello
```

```js
hello("Jupiter")
```

- chained calls aren't nested if single argument without grouping operator

```
"Jupiter" to uppercase to hello
```

```js
hello(uppercase("Jupiter"))
```

- grouping operator mandatory if multiple arguments

```
("Jupiter", 42) to hello
```

```js
hello("Jupiter", 42)
```



## Immediately Invoked Function Expression (IIFE)

- anonymous function that's called at declaration

```
"Jupiter" to &{
  in is name alias
  "Hello {name}!"
}
```

```js
((name) => {
  return `Hello ${name}!`
})("Jupiter")
```

- without arguments

```
to &{
  "Hello World!"
}
```

```js
(() => {
  
})()
```

- can use shorthand to leave of `to &`
- also called "block"

```
{
  "Hello World!"
}
```

- note: bare declaration syntax `{..}` calls function while extended declaration syntax `&{..}` returns function reference, bare identifier syntax `hello` returns function reference while extended identifier syntax `to hello` calls function



## Loop

- none, use tail recursive function instead
- an expression
- gives all benefits of functions
- can do any loop that wants, e.g. loop on multiple arguments simultaneously, condition check at beginning, etc.
- no separate syntax

```
&{
  in is i alias
  if i ?< 10 {
    i to print
    i + 1 to loop
  }
} is loop alias

1 to loop
// 1, 2, ..., 9
```

```js
function loop(i) {
  if (i < 10) {
    console.log(i)
    loop(i + 1)
  }
}

loop(1);
// 1, 2, ..., 9

for (let i = 1; i < 10; i += 1) {
  console.log(i)
}
// 1, 2, ..., 9

let i = 1
while (i < 10) {
  console.log(i)
  i += 1
}
// 1, 2, ..., 9
```

- can do condition check at end

```js
function loop(i) {
  console.log(i)
  if (i < 10) {
    loop(i + 1)
  }
}

loop(1);
// 1, 2, ..., 10

// no such for loop or while loop that checks condition at end before increment
// can use do...while but increment comes before condition check
// therefore do check at beginning for previous iteration and start with one less

let i = 0;
do {
  i += 1
  console.log(i);
} while (i < 10)
// 1, 2, ..., 10
```

- can't use IIFE because anonymous expression has no identifier to refer to itself,  must declare function and call it separately
<!-- todo: needs `continue` and `break`? -->

```
{
  &{
    in is x alias
    to loop
  } is loop alias
}
```
