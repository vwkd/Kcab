# Data Type



## Introduction

- set of values
- a value is data
- data is transformed, computer transforms input data to output data
- values flow through program, like water in a river
- data isn't fundamental, depends on goals of programmer, e.g. today humans might care about text
- hence values hence data types aren't fundamental
- in future might want new data types, might don't need old data types
- goal: have single data type that can hold any value
<!-- todo: is that even possible? -->



## Object

- a scope after it has run
- scope is already a key-value map, variables map identifiers to values
- can access own variables of scope (not from parent scope) using accessor operator `@`

```
myvar @ scope
```

- can get and set variables, mutable, since scope isn't needed for anything else
- like block (IIFE without arguments), except `[]` to indicate that it returns its scope instead of last value, also can't use return, like block has no arguments

```
[
    "Peter" =: name
    25 =: age
    ->: {
        "My name is {name} and I'm {age} years old."
    } =: sayHi
] =: myobj
```

```js
const myobj = {
    name: "Peter",
    age: 25,
    sayHi: function () { return `My name is ${this.name} and I'm ${this.age} years old.` }
}
```

- allows for arbitrary computations between variables like in block
- extracted method continues to work because it inherited outer scope as usual (accessor can't access outer scope)

```
sayHi @ myobj =: extractedSayHi
-> extractedSayHi -> print
// "My name is Peter and I'm 25 years old."
```

```js
const extractedSayHi = myobj.sayHi
console.log(extractedSayHi())
// "My name is undefined and I'm undefined years old."
```

<!-- todo: consider making function and object the same. But what happens if modifies properties of object? Would alter function behavior if called again... -->

### Inheritance

- none
- can use functions which return objects
<!-- todo: how? What is inheritance? -->
<!-- todo:
type annotation just needs to allow to specify something like `extend`, such that compiler can check if returned object implements all properties of returned object of another function
-->



## Standard Types

### None

```
None
```

- this is the data type for no value
- it has only a single value
- better name than `null` or `undefined`

## Numbers

```
12
```

- like a number

## Text

```
"Hello world!"
```

- like a string

### Interpolation

```
"Hello {str}"
```

- allows use of block, can do any computation in there like in function
- over multiple lines

## Bit

```
true
```

- like a boolean

## Set

```
-> new @ Set =: s
"hello" -> set @ s
0 -> get @ s
"hello" -> has @ s
```


```
(1, 2, false) =: set
1 -> index @ set
```

- a list of values
- can access elements using position index to `index` method ``
- deletion shifts index of elements

```js
const s = new Set();
s.set("hello", "world")
// no s.get()
s.has("hello)
```

## Map

```
-> new @ Map =: m
"hello", "world" -> set @ m
"hello" -> get @ m
"hello" -> has @ m
```

- a map of properties to values

```js
const m = new Map();
m.set("hello", "world")
m.get("hello)
m.has("hello)
```