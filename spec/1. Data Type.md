# Data Type



## Introduction

- set of values



## Motivation

- a value is data
- data is transformed, computer transforms input data to output data
- values flow through program, like water in a river
- data isn't fundamental, depends on goals of programmer, e.g. today humans might care about text
- hence values hence data types aren't fundamental
- today needs strings, numbers, booleans
- in future might want other data types
- therefore provide a single data type that can hold any value
- object is this most fundamental and only data type
- all other data types are an object, e.g. String, Number, Boolean etc.



## Object

- map of keys to values
- a scope after it has run, since scope is already a key-value map, name bindings map identifiers to values
- can access own variables of scope (not from parent scope) using accessor operator `@`

```
myvar @ scope
```

- can get and set variables, mutable, since scope isn't needed for anything else
- like block (IIFE without arguments), except `[]` to indicate that it returns its scope instead of last value, also can't use return, like block has no arguments

```
[
    "Peter" =: name
    25 =: age
    ->: {
        "My name is {name} and I'm {age} years old."
    } =: sayHi
] =: myobj
```

```js
const myobj = {
    name: "Peter",
    age: 25,
    sayHi: function () { return `My name is ${this.name} and I'm ${this.age} years old.` }
}
```

- allows for arbitrary computations between variables like in block
- extracted method continues to work because it inherited outer scope as usual (accessor can't access outer scope)

```
sayHi @ myobj =: extractedSayHi
-> extractedSayHi -> print
// "My name is Peter and I'm 25 years old."
```

```js
const extractedSayHi = myobj.sayHi
console.log(extractedSayHi())
// "My name is undefined and I'm undefined years old."
```

<!-- todo: consider making function and object the same. But what happens if modifies properties of object? Would alter function behavior if called again... -->

### Inheritance

- none
- can use functions which return objects
<!-- todo: how? What is inheritance? -->
<!-- todo:
type annotation just needs to allow to specify something like `extend`, such that compiler can check if returned object implements all properties of returned object of another function
-->



## Custom Data Types

- data types based on Object
<!-- todo: how? -->
- name must be UpperCamelCased



## Standard Library

- common custom data types
- can import
<!-- todo: how to import multiple variables when module can export only single return value?
maybe something like spread syntax ...importedObject
-->
<!-- todo: where to specify auto import, e.g. language version -->
- may be infinitely many, e.g. string, number, etc.
<!-- todo: how to implement infinitely many variables under the hood? e.g. numbers, strings -->

### Scalar Types / Primitive Types

- ??
- implemented as immutable variables
- e.g. before importing `Number` from standard library could name any identifier `1`
- e.g. after importing `Number` from standard library there is a constant variable named `1`

#### None

```
none
```

- "no value" value, single value
- object `None`
- better name than `null` or `undefined`

#### Number

```
42
```

- number values, infinite values
- object `Number`
- no integer, float, double etc. types
- import all values

```
-> all @ String =: ...
```

- import single value

```
-> 42 @ String =: 42
```

#### String

```
"Hello world!"
```

- text values, infinite values
- object `String`
- no char type, because there is no digit type for numbers either
- supports any character including line breaks, i.e. multi-line string
- import all values

```
-> all @ String =: ...
```

- import single value

```
-> "Peter" @ String =: "Peter"
```

##### Interpolation

```
"Hello {str}"
```

- uses block
- can do any computation since block

#### Boolean

```
true
```

- bit values, two values
- object `Boolean`
- import all values

```
-> all @ Boolean =: ...
```

- import single value

```
-> true @ Boolean =: true
-> false @ Boolean =: false
```

### Compound Types

- ??
- import
<!-- todo: how? already imported? -->

#### List

```
-> new @ List =: mylist
"John", "Jim", "Jill" -> add @ mylist
-1 -> get @ mylist
2 -> delete @ mylist
```

- list of values
- object `List`
- not unique, i.e. duplicate insertions are allowed
- ordered by order of insertion
- deletion shifts index accordingly, i.e. no gaps
- exposes index, offers `get` method
- many helper methods, e.g. isEmpty, each, etc.

#### Set

```
-> new @ Set =: myset
"Jill", ..., "Lara" -> add @ myset
"Frank" -> has @ myset
"Tom" -> delete @ myset
```

- set of values
- object `Set`
- unique, i.e. duplicate insertions are ignored
- ordered by order of insertion
- deletion shifts index accordingly
- doesn't expose index, no `get` method
- many helper methods, e.g. isEmpty, each, etc.

```js
const myset = new Set();
myset.add("Jill")
myset.add("Tom")
myset.add("Lara")
myset.has("Frank")
myset.delete("Tom")
```