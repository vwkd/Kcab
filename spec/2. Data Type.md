# Data Type



## Introduction

- set of values



## Motivation

- a value is data
- data is transformed, computer transforms input data to output data
- values flow through program, like water in a river
- data isn't fundamental, depends on goals of programmer
- hence values and hence data types aren't fundamental
- today needs strings, numbers, booleans
- in future might want other data types
- therefore provide only a single data type
- object is this most fundamental and only data type
- every value is of data type object
- value is just identifier for variable that references the object



## Object

- map of keys to values
- a scope after it has run, since scope is already a key-value map, maps identifiers to values
- can get and set *own* variables of scope (not from parent scope) since scope isn't needed for anything else
- can set variables only if mutable, else are frozen

### Creation

- like block (IIFE without arguments), except `[]` to indicate that it returns its scope instead of last value, also can't use return, no arguments like block
- in method can access properties from object, because are just variables in inherited outer scope, no need for `this`

<!-- todo: figure out String interpolation -->

```
[
    "Peter" =: name
    25 =: age
    ->: {
        "My name is {name} and I'm {age} years old."
    } =: sayHi
] =: myobj
```

```js
const myobj = {
    name: "Peter",
    age: 25,
    sayHi: function () {
        return `My name is ${this.name} and I'm ${this.age} years old.`
        }
}
```

- allows for arbitrary computations between variables like in block

### Accessing

- can access *own* variables of scope (not from parent scope)

```
myvar @ scope
```

```js
scope.myvar
```

- chained calls of computed variables instead of nesting
<!-- todo: how differentiates between variable and identifier? -->

```
name @ person @ group
```

```js
group[person[name]]
```

- method using object properties still works after being extracted, because inherited outer scope

```
sayHi @ myobj =: extractedSayHi
-> extractedSayHi -> print
// "My name is Peter and I'm 25 years old."
```

```js
const extractedSayHi = myobj.sayHi
console.log(extractedSayHi())
// "My name is undefined and I'm undefined years old."
```

### Method chaining

- method that returns another object
- don't use here because is backwards (!)
- flow of value is right-to-left instead of with reading direction from left-to-right
- needs nesting using grouping operator
- i.e. all just opposite of traditional language, here method chaining is nested and backwards, there function chaining is nested and backwards

```
print -> each @ (-> sort (5 -> first @ list))
```

```js
list.first(5).sort().each(print)
```

- instead use function chaining, i.e. top-level functions

```
list -> firstFive -> sort -> print
```

### Inheritance

- none
- can use functions which create objects

```
name ->: {
    [
        name =: name
    ]
} =: Person

name, id ->: {
    [
        name -> Person =: ...
        id =: id
    ]
} =: Employee
```

```js
function Person(name) {
    return {
        name: name
    }
}

function Employee(name, id) {
    return {
        ...Person(name),
        id: id
    }
}
```



## Custom Data Type

- object
- with methods for operators, see Operators
- with `values` property for container object that contains of all value objects

```
42 @ values @ Number =: 42
```

<!-- todo: how to implement infinitely many variables under the hood? e.g. numbers, strings
needs infinitely many variables in object?
-->
- note: can't use `42 -> new @ Number` because identifier is undefined before
- properties must be immutable such that can't overwrite
- to customise a data type create new custom data type with inheritance
- name of data type object is by convention UpperCamelCased
- can declare all values by conveniently spreading out container object

```
values @ Number =: ...
```



## Standard Library

- common custom data types
- current version of language automatically declares scalar values
<!-- todo: also auto-declare compound types? -->
<!-- todo: how to import? Figure out Module Import first -->

### Scalar Types / Primitive Types

- "value" is single value

#### None

```
none
```

- "no value" value, single value
- object `None`
- better name than `null` or `undefined`

#### Number

```
42
```

- real number values, infinitely many values
- data type object `Number`
- no integer, float, double etc. types
- many helper methods on data type object, e.g. size, isInfinity, etc.
<!-- todo: what about notation? e.g. `4.2` or `4.2e+1`? just identifiers as well? -->

#### String

<!-- todo: how can have identifier with white space, line break or other language characters? e.g. currently parses as two identifiers `"Hello` and `world!"` -->
<!-- todo: how can have string that isn't mistaken as number or boolean? -->
<!-- todo: how to not conflict with methods of data type object? -->

```
"Hello world!"
```

- text values, infinitely many values
- data type object `String`
- no char type, because there is no digit type for numbers either
- supports any character including line breaks, i.e. multi-line string
- many helper methods on data type object, e.g. `size`, `isEmpty`, `each`, `contains, `startsWith`, `endsWith`, etc.
- no string interpolation, can use built-in `add` method on `String` object
<!-- todo: is there a better way? problem is that these are all just identifiers for variables -->

```
"Hello ", str, " world" -> add @ String
```

#### Boolean

```
true
```

- bit values, two values
- object `Boolean`
- many helper methods on data type object, e.g. isTrue, isFalse, etc.

### Compound Types

- "value" is collection of multiple scalar values
- `new` method that returns new value object
- value object has methods to set the scalar values

#### List

```
-> new @ List =: mylist
"John", "Jim", "Jill" -> add @ mylist
1 -> get @ mylist
2 -> delete @ mylist
```

- list of values
- object `List`
- not unique, i.e. duplicate insertions are allowed
- ordered by order of insertion
- deletion shifts index accordingly, i.e. no gaps
- exposes index, offers `get` method
- many helper methods on data type object, e.g. size, isEmpty, each, has, etc.

```js
const mylist = ["John", "Jim", "Jill"]
mylist[1]
// no straightforward way to delete in JS
```

#### Set

```
-> new @ Set =: myset
"John", "Jim", "Jill" -> add @ myset
"Jim" -> delete @ myset
```

- set of values
- object `Set`
- unique, i.e. duplicate insertions are ignored
- ordered by order of insertion
- deletion shifts index accordingly
- doesn't expose index, no `get` method
- many helper methods on data type object, e.g. size, isEmpty, each, has, etc.

```js
const myset = new Set();
myset.add("John")
myset.add("Jim")
myset.add("Jill")
myset.delete("Jim")
```