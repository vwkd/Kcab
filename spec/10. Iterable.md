# Iterable



## Introduction

- sequence of values over time
- can think of as single changing value if time interval is small enough
- changing value is pulled by consumer
<!-- todo: find better name: puller? -->
<!-- todo: largely similar to JS -->



## Iterator

- object with `next` method
- `next` returns object with `value` and `done` fields



## Iterable

- object with `iterator` method
- `iterator` returns an iterator
<!-- note: in JS the method's name is a Symbol.iterator, but don't care about it right now -->

- built-in functions in `Iterable` object that iterate an iterable

```
iterable -> filterNonZero -> print
```

- built-in function either takes iterable if first in chain or gets iterator from previous call if later in chain

<!-- todo: figure this out -->
```js
const iterator = (function() {
    let id = 0;

    return {
        next() {
            id += 1;
            return { value: id, done: false };
        }
    };
})();

const iterable = {
    iterator: function() {
    let id = 0;

    return {
        next() {
            id += 1;
            return { value: id, done: false };
        }
    };
}
}

function middleware(input) {
    let iterator

    // still iterable, first in function chain
    if(input.iterable) {
        iterator = input.iterator
    // already iterator, later in chain
    } else {
        iterator = input
    }

    // todo: do transformations to iterator
    const newIterator = iterator
    
    return newIterator
}
```


```
iterator -> iterate @ Iterable
```

- object that returns iterator in `new` method
<!-- todo: should force to use built-in object to build iterable?? e.g. `iterator -> new @ Iterable` -->
<!-- todo: can just make everything an iterable iterator? inherit a `new` and other helper methods? -->
- iterable has other helper methods, e.g. `iterate` method that iterates the iterator, instead of a `for...of` loop

```
print -> iterate @ counter
```

<!-- todo: don't use instance method, because method chaining is ugly here, instead use static method on the Data Type object -->
<!-- todo: part of the standard lib? -->
<!-- todo: can just create iterable iterator instead? needs to have the `new` method returning a new iterator -->



## Generator

- function with special syntax that creates iterable iterator
- looks like function that can pause and resume, pauses by returning some value, resumes when called again with new arguments
- same scope, instead of multiple normal functions with separate scopes
<!-- can every function be a generator where a normal function is just the limit where a generator has zero pauses and runs to completion? -->